<#

.SYNOPSIS
    Compiles PowerShell scripts into one file with a stager.
    
.DESCRIPTION
    Compiles PowerShell scripts with stager into one .ps1 file. Scripts are executed in alphabetical order.

.EXAMPLE
    Compile-PowerShellScripts file1.ps1 file2.ps1 -saveas compiled.ps1
    Compile-PowerShellScripts directory -saveas compiled.ps1

.NOTES
    Author: John Pan (https://github.com/snpm)
#>

function Compile-PowerShellScript {
    [CmdletBinding(DefaultParameterSetName='Parameter Set 1',
                   SupportsShouldProcess=$true,
                   PositionalBinding=$false,
                   HelpUri = 'http://www.microsoft.com/',
                   ConfirmImpact='Medium')]
    [OutputType([String])]
    Param (
        # Param1 help description
        [Parameter(Mandatory=$true,
                   Position=0,
                   ValueFromPipeline=$true,
                   ParameterSetName='Parameter Set 1')]
        [ValidateScript({
            if(-Not ($_ | Test-Path -PathType 'Leaf') ){
                throw "File does not exist"
            }
            if($_ -notmatch "(\.ps1)"){
                throw "File must be a PowerShell .ps1 file"
            }
            $true
        })]
        [string[]]$FilePath,

        [ValidateScript({
            if(-Not ($_ | Test-Path -isvalid) ){
                throw "File path not valid"
            }
            $true
        })]
        [string]$SaveAs
    )
    
    begin {
    }
    
    process {

        #Load file contents into $filesContent as single strings
        $scriptContents = @()
        #TODO: Support switches other than -FilePath
        foreach ($fp in $FilePath) {
            $scriptContents += get-content $fp | out-string
        }

        $compiled = _CompileScripts $scriptContents

        if (![string]::IsNullOrEmpty($SaveAs)) {
            $compiled | Out-File -FilePath $SaveAs
        }
        
        return $compiled
    }
    
    end {
    }
}

#Does the heavy lifting
function _CompileScripts ($scriptContents) {
    $CONFIG=@{
        DELIM='###cc8537317288bb7f3472de03dcf24c13###';
        DELIM_SUB = '<DELIM>'

        PAYLOAD_HEADER = '<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#<#'
        PAYLOAD_FOOTER="#>"


#Stager loads scripts!
STAGER = @'
$DELIM = '<DELIM>'
#Get script blocks
$invocation = $MyInvocation.MyCommand.Definition
$payload = $Invocation -split $DELIM
#Cut out staging code
$payload = $payload[2..($payload.Count-2)]

#Convert to scriptblocks and run
$scriptblocks = $payload | %{return [scriptblock]::Create($_)}
foreach ($sb in $scriptblocks) {
    . $sb
}
'@

    }

    #Use StringBuilder to build the compiled file
    $compileBuilder = new-object System.Text.StringBuilder
    #PowerShell returning things I don't want is annoying :p
    . {
        $stager = $CONFIG.STAGER -replace $CONFIG.DELIM_SUB,$CONFIG.DELIM
        $compileBuilder.AppendLine($stager)
        $compileBuilder.AppendLine($CONFIG.PAYLOAD_HEADER)
        $compileBuilder.AppendLine($CONFIG.DELIM)

        #Copy paste payload (compiled scripts) in here!
        for ($i = 0; $i -lt $scriptContents.Count; $i++) {
            if ($i -gt 0) {
                $compileBuilder.AppendLine($CONFIG.DELIM)
            }
            $content = $scriptContents[$i] | out-string
            $compileBuilder.AppendLine($content)
        }

        $compileBuilder.AppendLine($CONFIG.DELIM)
        $compileBuilder.AppendLine($CONFIG.PAYLOAD_FOOTER)
        $compileBuilder.AppendLine("#Generated by PowerKeg Compile-PowerShellScript on $(get-date)")
    } | out-null
    return $compileBuilder.ToString()
}
